# A block command has a start tag, an end tag, and possibly modifier tags. The
# content between tags may span multiple lines, and contain subs itself. For
# instance, here is a hypothetical `[show-unless-locked]` block command:
#
#     <p>Here is a sample sentence.</p>
#     [show-unless-locked]
#       <p>This text won't be shown if the post is locked.
#     [/show-unless-locked]
#
# Here is a more common `[if]...[else]...[end]` block that shows the concept
# of modifier tags:
#
# ~~~
# [if some-condition]
#   <p>Show this</p>
# [else]
#   <p>Show this instead</p>
# [end]
# ~~~
#
# As this is just an abstract class, it is not designed to be used directly but
# subclassed instead. For instance, at this time Papyrus does not have any
# built-in block commands, but if it did, they would also be subclasses of
# BlockCommand. There is also a CustomBlockCommand which is used to represent
# block commands that come from a CustomCommandSet.
#

#
require 'forwardable'

module Papyrus
  class BlockCommand < Command
    extend Forwardable

    # A BlockCommand is also a context object, not so much for storing
    # values but for ease in retrieving them from ancestors.
    include ContextItem

    # ## Public interface

    # #### BlockCommand.new
    #
    # ||Arguments:||
    #
    # * `name` -- The String name of the command.
    # * `args` -- The NodeList of arguments given to the command.
    # * `raw_tokens` -- A TokenList that represents the entire BlockCommand,
    #   generated by the Tokenizer.
    #
    # You must override this method in your subclass of BlockCommand.
    #
    def initialize(*args)
      if self.class == BlockCommand
        raise TypeError, 'BlockCommand.new should not be called directly'
      end
      super
    end

    # #### BlockCommand#active_block
    #
    # Since BlockCommands have the ability to contain multiple blocks, this
    # method returns (at least in theory) the block within this BlockCommand
    # that the Parser is currently looking as it is iterating over it.
    #
    # You must override this method in your subclass of BlockCommand. It must
    # return a NodeList.
    #
    # TODO: At the moment, this method is not used
    #
    def active_block
      raise NotImplementedError, 'BlockCommand#active_block should be overridden by a subclass'
    end

    # #### BlockCommand#add (#<<)
    #
    # Convenience method to work directly with the currently active block by
    # adding a Node to it.
    #
    # ||Arguments:||
    #
    # * `node` -- A Node object of any type.
    #
    # Raises a TypeError if `node` is not a Node.
    #
    # Returns the NodeList which is the active_block.
    #
    delegate [:add, :<<] => :active_block

    # #### BlockCommand#to_s
    #
    # A convenience method.
    #
    # Returns a String.
    #
    def to_s
      "[ #{@name} ]"
    end
  end
end

