# The CustomBlockCommand class is reserved for block commands which have been
# imported into the Papyrus lexicon using a CustomCommandSet. It is one of three
# possible node types which the Parser produces.
#
module Papyrus
  class CustomBlockCommand < BlockCommand
    # ## Instance variables

    # #### @orig_args
    #
    # This is a backup of the `args` argument given to the initializer. This is
    # because #evaluate will destructively modify @args. A NodeList.
    #
    attr_reader :orig_args

    # #### @orig_nodes
    #
    # This is a backup of @nodes set in the initializer. This is because
    # #evaluate will destructively modify @nodes. A NodeList.
    #
    attr_reader :orig_nodes

    # #### @evaluated_args
    #
    # The Array<String> evaluated version of @args.
    #
    attr_reader :evaluated_args

    # #### @evaluated_nodes
    #
    # The String fully evaluated version of @nodes.
    #
    attr_reader :evaluated_nodes

    # ## Public methods

    # #### CustomBlockCommand.new
    #
    # ||Arguments:||
    #
    # These are the same as BlockCommand, namely:
    #
    # * `name` -- The String name of the command.
    # * `args` -- The NodeList of arguments given to the command.
    # * `raw_tokens` -- A TokenList that represents the entire BlockCommand,
    #   generated by the Tokenizer.
    #
    def initialize(*args)
      super
      @nodes = NodeList.new
      @nodes.parent = self
    end

    # #### CustomBlockCommand#active_block
    #
    # At the moment, we assume that block commands only have one block
    # (modifiers are not supported, in other words). Hence, this just returns
    # the entire NodeList this command contains.
    #
    def active_block
      @nodes
    end

    # #### CustomBlockCommand#evaluate
    #
    # Turns a CustomBlockCommand into a String.
    #
    # If the command is successfully evaluated, returns the String result of the
    # evaluation, otherwise returns the String unevaluated representation of
    # the command as it originally appeared in the document.
    #
    def evaluate
      # Since evaluating a NodeList can possibly mutate it, back it up.
      @orig_args = @args.clone
      @evaluated_args = @args.to_a
      @orig_nodes = @nodes.clone
      @evaluated_nodes = @nodes.evaluate.join

      if evaluate? && _evaluates_as_command_or_variable?
        @raw_tokens.replace([ Token::Text.new(@result) ])
        return @result
      else
        return raw_sub
      end
    end

    # ## Internal methods

    # #### CustomBlockCommand#pretty_print_instance_variables
    #
    # Tells PrettyPrint which ivars to include in the output.
    #
    def pretty_print_instance_variables
      super + ["@nodes"]
    end

    # ## Private methods

    def _evaluates_as_command_or_variable?
      _evaluates_as_custom_block_command? or _evaluates_as_variable?
    end

    def _evaluates_as_custom_block_command?
      exec_command = (
        _command_allowed? &&
        self.template.custom_commands.class.has_block_command?(@name)
      )
      if exec_command
        @result = self.template.custom_commands.__call_block_command__(self)
        return true
      else
        return false
      end
    rescue ParserError => e
      return false
    end
  end
end
